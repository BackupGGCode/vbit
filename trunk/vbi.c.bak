/** ***************************************************************************
 * Description       : VBI timing control for VBIT
 * Compiler          : GCC
 *
 * Copyright (C) 2010 Peter Kwan
 *
 * Permission to use, copy, modify, and distribute this software
 * and its documentation for any purpose and without fee is hereby
 * granted, provided that the above copyright notice appear in all
 * copies and that both that the copyright notice and this
 * permission notice and warranty disclaimer appear in supporting
 * documentation, and that the name of the author not be used in
 * advertising or publicity pertaining to distribution of the
 * software without specific, written prior permission.
 *
 * The author disclaim all warranties with regard to this
 * software, including all implied warranties of merchantability
 * and fitness.  In no event shall the author be liable for any
 * special, indirect or consequential damages or any damages
 * whatsoever resulting from loss of use, data or profits, whether
 * in an action of contract, negligence or other tortious action,
 * arising out of or in connection with the use or performance of
 * this software.
 *************************************************************************** **/
#include "vbi.h"
#include "../LEDs/LEDs.h"
/* hic sunt globals */
volatile uint8_t vbiDone; // Set when the timer reckons that the vbi is over. Cleared by main.
volatile uint32_t UTC=36000; // 10:00am

 /* Instantiate pointer to fieldPort. */
static PORT_t *fieldPort = &PORTC;
static TC0_t *timerControl = &TCD0;
/*! Field interrupt */
void FieldInterruptHandler(void)
{
	const uint32_t day=(uint32_t)60*60*24;
	LED_On( LED_3 );
	static int count=0;
	count++;
	/*if ((count%50)==0)
		xputs(PSTR("."));
	*/
	// Maintain the UTC.
	if ((count%50)==0)
	{
		UTC++;
		if (UTC>=day)
			UTC=0;
	}
	// What is the state of PINC.2
	// Also start the vbi timer
	// We want a preset 15625 samples at fosc/1 for 1024uS
	/* Set period/TOP value. */

	timerControl->PER=15625;
	/* Select clock source. */
	timerControl->CTRLA = ( timerControl->CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;	
	/* Set a low level overflow interrupt.*/
	timerControl->INTCTRLA|=TC_OVFINTLVL_LO_gc;
	PMIC.CTRL |= PMIC_LOLVLEN_bm;	
}

// TCC0, TCC1, TCD1 are all in use
/** VBI Timer done. Signal to the main code that it is clear to load the next field
 */
ISR(TCD0_OVF_vect)
{
	// At this point we want to kill the clock so as not to let it bother us
	timerControl->CTRLA = ( timerControl->CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;	
	if (vbiDone)
	{
		xputs(PSTR("ERR: vbi overrun\n"));
		// work out why we never made it
	}
	vbiDone=1;
	LED_Off( LED_3 );
}
 
/*! Set up the FLD interrupt */
void InitVBI(void)
{

	LEDs_Init();
	/* Configure Interrupt0 to have medium interrupt level, triggered by pin 2. */
	fieldPort->INTCTRL = ( fieldPort->INTCTRL & ~PORT_INT0LVL_gm ) | PORT_INT0LVL_MED_gc;
	// pin mask, pin 2 only
	fieldPort->INT0MASK = VBIT_FLD;

	/* Enable medium level interrupts in the PMIC. */
	PMIC.CTRL |= PMIC_MEDLVLEN_bm;	

	/* Build pin control register value. */
	uint8_t temp = PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;

	/* Configure the pins in one atomic operation. */

	/* Save status register. */
	uint8_t sreg = SREG;
	cli();
	PORTCFG.MPCMASK = VBIT_FLD; // Only pin 2
	fieldPort->PIN0CTRL = temp;

	/* Restore status register. */
	SREG = sreg;
	sei();
 }
 
 /*! PINC.2 FLD Interrupt vector. */
ISR(PORTC_INT0_vect)
{
	FieldInterruptHandler();
}
 /// ISR for vbi timer